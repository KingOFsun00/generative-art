<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Arte Generativa com IA</title>
    <meta name="description" content="Crie belas obras de arte generativas usando imagens do Unsplash e efeitos algorÃ­tmicos">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #3f37c9;
            --accent: #4895ef;
            --dark: #1b263b;
            --light: #f8f9fa;
            --success: #4cc9f0;
            --warning: #f72585;
            --gray: #adb5bd;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--dark);
            line-height: 1.6;
        }
        
        .container {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 900px;
            margin: 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, var(--primary), var(--accent), var(--warning));
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 1.5rem;
            font-weight: 600;
            font-size: 2rem;
            position: relative;
            display: inline-block;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--accent);
            border-radius: 3px;
        }
        
        .search-box {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            position: relative;
        }
        
        #searchInput {
            flex-grow: 1;
            padding: 0.75rem 1.25rem;
            border: 2px solid #e9ecef;
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        #searchInput:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        
        .search-box i {
            position: absolute;
            right: 110px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray);
            pointer-events: none;
        }
        
        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            background-color: var(--primary);
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background-color: var(--gray);
            cursor: not-allowed;
            transform: none !important;
        }
        
        #saveBtn {
            background-color: var(--success);
        }
        
        #saveBtn:hover {
            background-color: #3aa8d8;
        }
        
        #randomBtn {
            background-color: var(--warning);
        }
        
        #randomBtn:hover {
            background-color: #e5177e;
        }
        
        .canvas-container {
            position: relative;
            margin: 0 auto 1.5rem;
            width: fit-content;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }
        
        canvas {
            display: block;
            background-color: white;
            max-width: 100%;
            height: auto;
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            z-index: 10;
            backdrop-filter: blur(2px);
        }
        
        .spinner {
            width: 3rem;
            height: 3rem;
            border: 4px solid rgba(67, 97, 238, 0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .effect-controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .effect-btn {
            padding: 0.5rem 1rem;
            background-color: white;
            color: var(--dark);
            border: 1px solid #e9ecef;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
        }
        
        .effect-btn:hover {
            background-color: #f8f9fa;
            border-color: var(--accent);
            color: var(--primary);
        }
        
        .effect-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .settings-panel {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            text-align: left;
            display: none;
        }
        
        .settings-panel h3 {
            margin-bottom: 0.75rem;
            color: var(--primary);
            font-size: 1.1rem;
        }
        
        .slider-container {
            margin-bottom: 0.75rem;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e9ecef;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .toggle-settings {
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 0.5rem 1rem;
            margin-bottom: 1rem;
        }
        
        .toggle-settings:hover {
            background: rgba(67, 97, 238, 0.1);
        }
        
        .credits {
            margin-top: 1.5rem;
            font-size: 0.85rem;
            color: var(--gray);
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: var(--dark);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 0.5rem;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
                margin: 1rem;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .search-box {
                flex-direction: column;
            }
            
            .search-box i {
                right: 1rem;
                top: 1rem;
                transform: none;
            }
            
            button {
                width: 100%;
                justify-content: center;
            }
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gerador de Arte Generativa</h1>
        <p class="subtitle">Transforme suas imagens em obras de arte Ãºnicas</p>
        
        <div class="search-box">
            <i class="fas fa-search"></i>
            <input type="text" id="searchInput" placeholder="Digite um tema (ex: castelo, floresta, cidade futurista)">
            <button id="generateBtn">
                <i class="fas fa-magic"></i> Gerar Arte
            </button>
        </div>
        
        <button id="toggleSettings" class="toggle-settings">
            <i class="fas fa-sliders-h"></i> ConfiguraÃ§Ãµes AvanÃ§adas
        </button>
        
        <div class="settings-panel" id="settingsPanel">
            <h3>Efeitos ArtÃ­sticos</h3>
            <div class="effect-controls">
                <button class="effect-btn active" data-effect="brush">Pinceladas</button>
                <button class="effect-btn" data-effect="pixels">Pixelado</button>
                <button class="effect-btn" data-effect="glitch">Glitch</button>
                <button class="effect-btn" data-effect="watercolor">Aquarela</button>
            </div>
            
            <div class="slider-container">
                <label for="effectIntensity">Intensidade do Efeito</label>
                <input type="range" id="effectIntensity" min="1" max="10" value="5">
            </div>
            
            <div class="slider-container">
                <label for="colorVariance">VariaÃ§Ã£o de Cor</label>
                <input type="range" id="colorVariance" min="0" max="100" value="50">
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="artCanvas"></canvas>
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                <p>Processando sua obra de arte...</p>
            </div>
        </div>
        
        <div class="controls">
            <button id="saveBtn">
                <i class="fas fa-download"></i> Salvar Imagem
            </button>
            <button id="randomBtn">
                <i class="fas fa-random"></i> Tema AleatÃ³rio
            </button>
            <button id="shareBtn" class="tooltip">
                <i class="fas fa-share-alt"></i> Compartilhar
                <span class="tooltiptext">Copiar link para compartilhar</span>
            </button>
        </div>
        
        <p class="credits">
            Imagens fornecidas pelo <a href="https://unsplash.com" target="_blank">Unsplash</a> | 
            Efeitos algorÃ­tmicos personalizados
        </p>
    </div>

    <script>
        // ConfiguraÃ§Ãµes avanÃ§adas
        const CONFIG = {
            unsplashAccessKey: 'AFHvJmJON5UsXS5uhW1x9y2omkl4dIUhJJYTc38j5gc',
            randomThemes: [
                'medieval castle at sunset', 
                'enchanted forest with fog',
                'futuristic cyberpunk city',
                'ocean waves crashing',
                'mountain landscape with aurora',
                'desert with dramatic clouds',
                'deep space galaxy',
                'abstract colorful geometry',
                'japanese cherry blossoms',
                'ancient ruins jungle',
                'surreal dreamscape',
                'neon lights night',
                'underwater coral reef',
                'winter wonderland',
                'steampunk machinery'
            ],
            defaultEffects: {
                intensity: 5,
                colorVariance: 50,
                activeEffect: 'brush'
            },
            cache: {
                enabled: true,
                maxAge: 24 * 60 * 60 * 1000 // 24 horas
            }
        };
        
        // Elementos DOM
        const elements = {
            canvas: document.getElementById('artCanvas'),
            ctx: document.getElementById('artCanvas').getContext('2d'),
            searchInput: document.getElementById('searchInput'),
            generateBtn: document.getElementById('generateBtn'),
            saveBtn: document.getElementById('saveBtn'),
            randomBtn: document.getElementById('randomBtn'),
            shareBtn: document.getElementById('shareBtn'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            toggleSettings: document.getElementById('toggleSettings'),
            settingsPanel: document.getElementById('settingsPanel'),
            effectIntensity: document.getElementById('effectIntensity'),
            colorVariance: document.getElementById('colorVariance'),
            effectButtons: document.querySelectorAll('.effect-btn')
        };
        
        // Estado da aplicaÃ§Ã£o
        const state = {
            currentImage: null,
            currentTheme: '',
            isLoading: false,
            effects: {...CONFIG.defaultEffects},
            history: [],
            historyIndex: -1
        };
        
        // InicializaÃ§Ã£o
        document.addEventListener('DOMContentLoaded', () => {
            setupCanvas();
            setupEventListeners();
            checkURLParams();
            
            // Verificar se hÃ¡ suporte para Service Worker e Cache API
            if ('serviceWorker' in navigator && 'caches' in window) {
                registerServiceWorker();
            }
            
            // Carregar preferÃªncias do localStorage
            loadPreferences();
            
            // Gerar um tema aleatÃ³rio inicial
            if (!state.currentTheme) {
                generateRandomTheme();
            }
        });
        
        function setupCanvas() {
            const size = Math.min(window.innerWidth - 40, 600);
            elements.canvas.width = size;
            elements.canvas.height = size;
            drawPlaceholder();
        }
        
        function drawPlaceholder() {
            const {ctx, canvas} = elements;
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#f0f0f0');
            gradient.addColorStop(1, '#e0e0e0');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#999';
            ctx.font = '16px Poppins';
            ctx.textAlign = 'center';
            
            const lines = [
                'Digite um tema acima',
                'e clique em "Gerar Arte"',
                'ou use um tema aleatÃ³rio'
            ];
            
            lines.forEach((line, i) => {
                ctx.fillText(line, canvas.width/2, canvas.height/2 - 20 + (i * 25));
            });
            
            // Adicionar um Ã­cone decorativo
            ctx.font = '48px "Font Awesome 6 Free"';
            ctx.fillText('\uf53f', canvas.width/2, canvas.height/2 - 70);
        }
        
        function setupEventListeners() {
            // Eventos de geraÃ§Ã£o
            elements.generateBtn.addEventListener('click', handleGenerate);
            elements.searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleGenerate();
            });
            
            // Debounce para busca enquanto digita
            let searchTimeout;
            elements.searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    if (elements.searchInput.value.trim().length > 2) {
                        handleGenerate();
                    }
                }, 800);
            });
            
            // Eventos de controle
            elements.saveBtn.addEventListener('click', saveImage);
            elements.randomBtn.addEventListener('click', generateRandomTheme);
            elements.shareBtn.addEventListener('click', shareArtwork);
            
            // Eventos de efeitos
            elements.toggleSettings.addEventListener('click', toggleSettingsPanel);
            elements.effectIntensity.addEventListener('input', updateEffectSettings);
            elements.colorVariance.addEventListener('input', updateEffectSettings);
            
            elements.effectButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.effectButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.effects.activeEffect = btn.dataset.effect;
                    if (state.currentImage) {
                        applyArtisticEffects(state.currentImage);
                    }
                    savePreferences();
                });
            });
            
            // Eventos de janela
            window.addEventListener('resize', () => {
                setupCanvas();
                if (state.currentImage) {
                    applyArtisticEffects(state.currentImage);
                }
            });
        }
        
        function toggleSettingsPanel() {
            elements.settingsPanel.style.display = 
                elements.settingsPanel.style.display === 'block' ? 'none' : 'block';
            savePreferences();
        }
        
        function updateEffectSettings() {
            state.effects.intensity = parseInt(elements.effectIntensity.value);
            state.effects.colorVariance = parseInt(elements.colorVariance.value);
            
            if (state.currentImage) {
                applyArtisticEffects(state.currentImage);
            }
            
            savePreferences();
        }
        
        async function handleGenerate() {
            const query = elements.searchInput.value.trim();
            if (!query || state.isLoading) return;
            
            try {
                state.currentTheme = query;
                updateURLParams();
                showLoading(true);
                
                // Verificar cache primeiro
                const cachedImage = CONFIG.cache.enabled ? await checkImageCache(query) : null;
                
                if (cachedImage) {
                    state.currentImage = cachedImage;
                    await applyArtisticEffects(cachedImage);
                } else {
                    const imageUrl = await fetchUnsplashImage(query);
                    state.currentImage = imageUrl;
                    await applyArtisticEffects(imageUrl);
                    
                    // Armazenar no cache
                    if (CONFIG.cache.enabled) {
                        cacheImage(query, imageUrl);
                    }
                }
                
                // Adicionar ao histÃ³rico
                addToHistory(query);
            } catch (error) {
                console.error("Erro ao gerar arte:", error);
                showError("NÃ£o foi possÃ­vel criar a arte. Tente outro termo ou verifique sua conexÃ£o.");
            } finally {
                showLoading(false);
            }
        }
        
        async function checkImageCache(query) {
            if (!CONFIG.cache.enabled) return null;
            
            try {
                const cache = await caches.open('art-generator-cache');
                const cacheKey = `image-${encodeURIComponent(query)}`;
                const response = await cache.match(cacheKey);
                
                if (response) {
                    const blob = await response.blob();
                    return URL.createObjectURL(blob);
                }
                return null;
            } catch (error) {
                console.warn("Erro ao acessar cache:", error);
                return null;
            }
        }
        
        async function cacheImage(query, imageUrl) {
            try {
                const cache = await caches.open('art-generator-cache');
                const cacheKey = `image-${encodeURIComponent(query)}`;
                const response = await fetch(imageUrl);
                
                if (response.ok) {
                    await cache.put(cacheKey, response.clone());
                }
            } catch (error) {
                console.warn("Erro ao armazenar no cache:", error);
            }
        }
        
        async function fetchUnsplashImage(query) {
            try {
                const response = await fetch(
                    `https://api.unsplash.com/search/photos?query=${encodeURIComponent(query)}&per_page=5&client_id=${CONFIG.unsplashAccessKey}`
                );
                
                if (!response.ok) {
                    throw new Error(`Erro na API: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.results || data.results.length === 0) {
                    throw new Error("Nenhuma imagem encontrada para este tema");
                }
                
                // Selecionar uma imagem aleatÃ³ria entre os resultados
                const randomIndex = Math.floor(Math.random() * Math.min(5, data.results.length));
                return data.results[randomIndex].urls.regular;
            } catch (error) {
                console.error("Erro ao buscar imagem:", error);
                throw error;
            }
        }
        
        async function applyArtisticEffects(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                
                img.onload = function() {
                    // Redimensionar mantendo proporÃ§Ã£o
                    const ratio = Math.min(
                        elements.canvas.width / img.width,
                        elements.canvas.height / img.height
                    );
                    const newWidth = img.width * ratio;
                    const newHeight = img.height * ratio;
                    
                    // Limpar e desenhar a imagem base
                    elements.ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                    elements.ctx.save();
                    elements.ctx.drawImage(
                        img,
                        (elements.canvas.width - newWidth) / 2,
                        (elements.canvas.height - newHeight) / 2,
                        newWidth,
                        newHeight
                    );
                    
                    // Aplicar efeito selecionado
                    switch (state.effects.activeEffect) {
                        case 'brush':
                            applyBrushStrokeEffect();
                            break;
                        case 'pixels':
                            applyPixelEffect();
                            break;
                        case 'glitch':
                            applyGlitchEffect();
                            break;
                        case 'watercolor':
                            applyWatercolorEffect();
                            break;
                        default:
                            applyBrushStrokeEffect();
                    }
                    
                    elements.ctx.restore();
                    resolve();
                };
                
                img.src = imageUrl;
            });
        }
        
        function applyBrushStrokeEffect() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const colorVar = state.effects.colorVariance;
            
            // Configurar parÃ¢metros baseados na intensidade
            const strokeCount = 100 + (intensity * 30);
            const maxSize = 20 + (intensity * 5);
            const opacity = 0.05 + (intensity * 0.01);
            
            // Criar uma mÃ¡scara de pinceladas
            ctx.globalCompositeOperation = 'overlay';
            
            for (let i = 0; i < strokeCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * maxSize + 10;
                
                // Obter cor do pixel na posiÃ§Ã£o
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                let hue = Math.random() * colorVar - (colorVar / 2);
                
                if (pixel[3] > 0) {
                    // Converter RGB para HSL e variar a matiz
                    const rgb = [pixel[0]/255, pixel[1]/255, pixel[2]/255];
                    const max = Math.max(...rgb);
                    const min = Math.min(...rgb);
                    let h = 0;
                    
                    if (max !== min) {
                        const d = max - min;
                        switch(max) {
                            case rgb[0]: h = (rgb[1] - rgb[2]) / d + (rgb[1] < rgb[2] ? 6 : 0); break;
                            case rgb[1]: h = (rgb[2] - rgb[0]) / d + 2; break;
                            case rgb[2]: h = (rgb[0] - rgb[1]) / d + 4; break;
                        }
                        h /= 6;
                    }
                    
                    hue = (h * 360 + hue) % 360;
                }
                
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${opacity})`;
                
                // Criar formas de pincel variadas
                ctx.beginPath();
                
                if (Math.random() > 0.7) {
                    // Pincelada retangular
                    const rotation = Math.random() * Math.PI * 2;
                    const width = size;
                    const height = size * (0.3 + Math.random() * 0.7);
                    
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    ctx.rect(-width/2, -height/2, width, height);
                    ctx.translate(-x, -y);
                } else if (Math.random() > 0.5) {
                    // Pincelada circular
                    ctx.arc(x, y, size/2, 0, Math.PI * 2);
                } else {
                    // Pincelada triangular
                    ctx.moveTo(x, y - size/2);
                    ctx.lineTo(x + size/2, y + size/2);
                    ctx.lineTo(x - size/2, y + size/2);
                }
                
                ctx.fill();
            }
            
            ctx.globalCompositeOperation = 'source-over';
            
            // Adicionar textura final
            addPaperTexture();
        }
        
        function applyPixelEffect() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const pixelSize = 10 - (intensity * 0.8);
            
            if (pixelSize <= 1) return;
            
            // Obter dados da imagem
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Aplicar efeito pixelado
            for (let y = 0; y < canvas.height; y += pixelSize) {
                for (let x = 0; x < canvas.width; x += pixelSize) {
                    // Obter a cor mÃ©dia na Ã¡rea do pixel
                    const pixelIndex = (y * canvas.width + x) * 4;
                    const r = data[pixelIndex];
                    const g = data[pixelIndex + 1];
                    const b = data[pixelIndex + 2];
                    
                    // Desenhar quadrado com a cor mÃ©dia
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, pixelSize, pixelSize);
                }
            }
            
            // Adicionar bordas entre pixels para efeito mais pronunciado
            if (intensity > 5) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 0.5;
                
                for (let y = 0; y <= canvas.height; y += pixelSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                for (let x = 0; x <= canvas.width; x += pixelSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
            }
        }
        
        function applyGlitchEffect() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const colorVar = state.effects.colorVariance;
            
            // Obter dados da imagem
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Aplicar variaÃ§Ã£o de cor
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < colorVar/500) {
                    // Deslocar canais de cor
                    const shift = Math.floor(Math.random() * 20 * (intensity/5)) - (10 * (intensity/5));
                    data[i] = Math.min(255, Math.max(0, data[i] + shift));     // R
                    data[i+1] = Math.min(255, Math.max(0, data[i+1] - shift)); // G
                    data[i+2] = Math.min(255, Math.max(0, data[i+2] + shift)); // B
                }
            }
            
            // Aplicar linhas de glitch
            const glitchLines = intensity * 5;
            for (let i = 0; i < glitchLines; i++) {
                const y = Math.floor(Math.random() * canvas.height);
                const height = 1 + Math.floor(Math.random() * 5 * (intensity/5));
                const shift = (Math.random() > 0.5 ? 1 : -1) * Math.floor(Math.random() * 20 * (intensity/5));
                
                const sourceY = Math.max(0, Math.min(canvas.height - height, y + shift));
                const destY = Math.max(0, Math.min(canvas.height - height, y));
                
                const glitchData = ctx.getImageData(0, sourceY, canvas.width, height);
                ctx.putImageData(glitchData, 0, destY);
            }
            
            // Aplicar blocos deslocados
            if (intensity > 5) {
                const blocks = Math.floor(intensity / 2);
                for (let i = 0; i < blocks; i++) {
                    const width = 10 + Math.floor(Math.random() * 50);
                    const height = 5 + Math.floor(Math.random() * 20);
                    const x = Math.floor(Math.random() * (canvas.width - width));
                    const y = Math.floor(Math.random() * (canvas.height - height));
                    const shiftX = (Math.random() > 0.5 ? 1 : -1) * Math.floor(Math.random() * 30);
                    
                    const blockData = ctx.getImageData(x, y, width, height);
                    ctx.putImageData(blockData, x + shiftX, y);
                }
            }
            
            // Adicionar ruÃ­do digital
            addDigitalNoise();
        }
        
        function applyWatercolorEffect() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const colorVar = state.effects.colorVariance;
            
            // Criar um canvas temporÃ¡rio para o efeito
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Desenhar a imagem original no canvas temporÃ¡rio
            tempCtx.drawImage(canvas, 0, 0);
            
            // Aplicar desfoque para simular aquarela
            const blurAmount = intensity * 2;
            tempCtx.filter = `blur(${blurAmount}px)`;
            tempCtx.drawImage(tempCanvas, 0, 0);
            tempCtx.filter = 'none';
            
            // Desenhar de volta no canvas principal com transparÃªncia
            ctx.globalAlpha = 0.7;
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.globalAlpha = 1.0;
            
            // Adicionar pinceladas de aquarela
            const strokeCount = 50 + (intensity * 20);
            const maxSize = 30 + (intensity * 5);
            
            for (let i = 0; i < strokeCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * maxSize + 10;
                
                // Obter cor do pixel na posiÃ§Ã£o com variaÃ§Ã£o
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                const hueShift = (Math.random() * colorVar) - (colorVar / 2);
                
                let r = pixel[0], g = pixel[1], b = pixel[2];
                
                if (pixel[3] > 0) {
                    // Converter para HSL, variar e converter de volta
                    const hsl = rgbToHsl(r, g, b);
                    hsl[0] = (hsl[0] + hueShift/360) % 1;
                    hsl[1] = Math.min(1, hsl[1] * (1 + (Math.random() * 0.2)));
                    hsl[2] = hsl[2] * (0.9 + Math.random() * 0.2);
                    
                    const rgb = hslToRgb(...hsl);
                    r = rgb[0];
                    g = rgb[1];
                    b = rgb[2];
                }
                
                // Criar pincelada com bordas difusas
                const gradient = ctx.createRadialGradient(
                    x, y, 0,
                    x, y, size
                );
                
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
                gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.1)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Adicionar textura de papel
            addPaperTexture(0.3);
        }
        
        function addDigitalNoise() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const noiseDensity = intensity / 20;
            
            // Criar ruÃ­do digital
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < noiseDensity) {
                    const val = Math.floor(Math.random() * 256);
                    data[i] = val;     // R
                    data[i+1] = val;   // G
                    data[i+2] = val;   // B
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function addPaperTexture(opacity = 0.1) {
            const {ctx, canvas} = elements;
            
            // Criar textura de papel
            ctx.globalAlpha = opacity || 0.1;
            
            for (let i = 0; i < canvas.width * canvas.height * 0.02; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 1.5;
                
                ctx.fillStyle = `rgba(200, 200, 200, ${Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        // FunÃ§Ãµes auxiliares de conversÃ£o de cor
        function rgbToHsl(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            return [h, s, l];
        }
        
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        function generateRandomTheme() {
            const randomTheme = CONFIG.randomThemes[Math.floor(Math.random() * CONFIG.randomThemes.length)];
            elements.searchInput.value = randomTheme;
            handleGenerate();
        }
        
        function saveImage() {
            if (!state.currentImage) return;
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = state.currentTheme 
                ? `arte-${state.currentTheme.toLowerCase().replace(/\s+/g, '-')}-${timestamp}`
                : `arte-generativa-${timestamp}`;
            
            link.download = `${filename}.png`;
            link.href = elements.canvas.toDataURL('image/png');
            link.click();
        }
        
        function shareArtwork() {
            if (!navigator.share) {
                // Fallback para copiar link
                const url = window.location.href.split('?')[0] + `?theme=${encodeURIComponent(state.currentTheme)}`;
                navigator.clipboard.writeText(url).then(() => {
                    alert('Link copiado para a Ã¡rea de transferÃªncia!');
                });
                return;
            }
            
            navigator.share({
                title: `Arte Generativa: ${state.currentTheme}`,
                text: 'Confira esta obra de arte generativa que criei:',
                url: window.location.href
            }).catch(err => {
                console.log('Erro ao compartilhar:', err);
            });
        }
        
        function showLoading(show) {
            state.isLoading = show;
            elements.loadingIndicator.style.display = show ? 'flex' : 'none';
            elements.generateBtn.disabled = show;
            
            if (show) {
                elements.generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processando...';
            } else {
                elements.generateBtn.innerHTML = '<i class="fas fa-magic"></i> Gerar Arte';
            }
        }
        
        function showError(message) {
            const errorEl = document.createElement('div');
            errorEl.className = 'error-message';
            errorEl.innerHTML = `
                <i class="fas fa-exclamation-circle"></i> ${message}
            `;
            errorEl.style.position = 'fixed';
            errorEl.style.top = '20px';
            errorEl.style.left = '50%';
            errorEl.style.transform = 'translateX(-50%)';
            errorEl.style.backgroundColor = 'var(--warning)';
            errorEl.style.color = 'white';
            errorEl.style.padding = '10px 20px';
            errorEl.style.borderRadius = '5px';
            errorEl.style.boxShadow = '0 3px 10px rgba(0,0,0,0.2)';
            errorEl.style.zIndex = '1000';
            errorEl.style.animation = 'fadeIn 0.3s ease-out';
            
            document.body.appendChild(errorEl);
            
            setTimeout(() => {
                errorEl.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => {
                    document.body.removeChild(errorEl);
                }, 300);
            }, 3000);
        }
        
        function updateURLParams() {
            if (!state.currentTheme) return;
            
            const url = new URL(window.location);
            url.searchParams.set('theme', state.currentTheme);
            window.history.pushState({}, '', url);
        }
        
        function checkURLParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const theme = urlParams.get('theme');
            
            if (theme) {
                elements.searchInput.value = theme;
                handleGenerate();
            }
        }
        
        function addToHistory(query) {
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(query);
            state.historyIndex = state.history.length - 1;
        }
        
        function loadPreferences() {
            const prefs = JSON.parse(localStorage.getItem('artGeneratorPrefs')) || {};
            
            if (prefs.effects) {
                state.effects = {...state.effects, ...prefs.effects};
                elements.effectIntensity.value = state.effects.intensity;
                elements.colorVariance.value = state.effects.colorVariance;
                
                // Ativar botÃ£o do efeito salvo
                elements.effectButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.effect === state.effects.activeEffect);
                });
            }
            
            if (prefs.settingsPanelVisible) {
                elements.settingsPanel.style.display = 'block';
            }
        }
        
        function savePreferences() {
            const prefs = {
                effects: state.effects,
                settingsPanelVisible: elements.settingsPanel.style.display === 'block'
            };
            
            localStorage.setItem('artGeneratorPrefs', JSON.stringify(prefs));
        }
        
        async function registerServiceWorker() {
            try {
                await navigator.serviceWorker.register('/sw.js');
                console.log('Service Worker registrado com sucesso');
            } catch (error) {
                console.log('Falha ao registrar Service Worker:', error);
            }
        }
    </script>
</body>
</html>