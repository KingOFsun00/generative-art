<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Arte Generativa com IA</title>
    <meta name="description" content="Crie belas obras de arte generativas usando imagens do Unsplash e efeitos algorítmicos">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #3f37c9;
            --accent: #4895ef;
            --dark: #1b263b;
            --light: #f8f9fa;
            --success: #4cc9f0;
            --warning: #f72585;
            --gray: #adb5bd;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--dark);
            line-height: 1.6;
        }
        
        .container {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 900px;
            margin: 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, var(--primary), var(--accent), var(--warning));
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 1.5rem;
            font-weight: 600;
            font-size: 2rem;
            position: relative;
            display: inline-block;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--accent);
            border-radius: 3px;
        }
        
        .search-box {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            position: relative;
        }
        
        #searchInput {
            flex-grow: 1;
            padding: 0.75rem 1.25rem;
            border: 2px solid #e9ecef;
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        #searchInput:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        
        .search-box i {
            position: absolute;
            right: 110px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray);
            pointer-events: none;
        }
        
        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            background-color: var(--primary);
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background-color: var(--gray);
            cursor: not-allowed;
            transform: none !important;
        }
        
        #saveBtn {
            background-color: var(--success);
        }
        
        #saveBtn:hover {
            background-color: #3aa8d8;
        }
        
        #randomBtn {
            background-color: var(--warning);
        }
        
        #randomBtn:hover {
            background-color: #e5177e;
        }
        
        .canvas-container {
            position: relative;
            margin: 0 auto 1.5rem;
            width: fit-content;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }
        
        canvas {
            display: block;
            background-color: white;
            max-width: 100%;
            height: auto;
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            z-index: 10;
            backdrop-filter: blur(2px);
        }
        
        .spinner {
            width: 3rem;
            height: 3rem;
            border: 4px solid rgba(67, 97, 238, 0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .effect-controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .effect-btn {
            padding: 0.5rem 1rem;
            background-color: white;
            color: var(--dark);
            border: 1px solid #e9ecef;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
        }
        
        .effect-btn:hover {
            background-color: #f8f9fa;
            border-color: var(--accent);
            color: var(--primary);
        }
        
        .effect-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .settings-panel {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            text-align: left;
            display: none;
        }
        
        .settings-panel h3 {
            margin-bottom: 0.75rem;
            color: var(--primary);
            font-size: 1.1rem;
        }
        
        .slider-container {
            margin-bottom: 0.75rem;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e9ecef;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .toggle-settings {
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 0.5rem 1rem;
            margin-bottom: 1rem;
        }
        
        .toggle-settings:hover {
            background: rgba(67, 97, 238, 0.1);
        }
        
        .credits {
            margin-top: 1.5rem;
            font-size: 0.85rem;
            color: var(--gray);
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: var(--dark);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 0.5rem;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
                margin: 1rem;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .search-box {
                flex-direction: column;
            }
            
            .search-box i {
                right: 1rem;
                top: 1rem;
                transform: none;
            }
            
            button {
                width: 100%;
                justify-content: center;
            }
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gerador de Arte Generativa</h1>
        <p class="subtitle">Transforme suas imagens em obras de arte únicas</p>
        
        <div class="search-box">
            <i class="fas fa-search"></i>
            <input type="text" id="searchInput" placeholder="Digite um tema (ex: castelo, floresta, cidade futurista)">
            <button id="generateBtn">
                <i class="fas fa-magic"></i> Gerar Arte
            </button>
        </div>
        
        <button id="toggleSettings" class="toggle-settings">
            <i class="fas fa-sliders-h"></i> Configurações Avançadas
        </button>
        
        <div class="settings-panel" id="settingsPanel">
            <h3>Efeitos Artísticos</h3>
            <div class="effect-controls">
                <button class="effect-btn active" data-effect="brush">Pinceladas</button>
                <button class="effect-btn" data-effect="pixels">Pixelado</button>
                <button class="effect-btn" data-effect="glitch">Glitch</button>
                <button class="effect-btn" data-effect="watercolor">Aquarela</button>
            </div>
            
            <div class="slider-container">
                <label for="effectIntensity">Intensidade do Efeito</label>
                <input type="range" id="effectIntensity" min="1" max="10" value="5">
            </div>
            
            <div class="slider-container">
                <label for="colorVariance">Variação de Cor</label>
                <input type="range" id="colorVariance" min="0" max="100" value="50">
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="artCanvas"></canvas>
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                <p>Processando sua obra de arte...</p>
            </div>
        </div>
        
        <div class="controls">
            <button id="saveBtn">
                <i class="fas fa-download"></i> Salvar Imagem
            </button>
            <button id="randomBtn">
                <i class="fas fa-random"></i> Tema Aleatório
            </button>
            <button id="shareBtn" class="tooltip">
                <i class="fas fa-share-alt"></i> Compartilhar
                <span class="tooltiptext">Copiar link para compartilhar</span>
            </button>
        </div>
        
        <p class="credits">
            Imagens fornecidas pelo <a href="https://unsplash.com" target="_blank">Unsplash</a> | 
            Efeitos algorítmicos personalizados
        </p>
    </div>

    <script>
        // Configurações avançadas
        const CONFIG = {
            unsplashAccessKey: 'AFHvJmJON5UsXS5uhW1x9y2omkl4dIUhJJYTc38j5gc',
            randomThemes: [
                'medieval castle at sunset', 
                'enchanted forest with fog',
                'futuristic cyberpunk city',
                'ocean waves crashing',
                'mountain landscape with aurora',
                'desert with dramatic clouds',
                'deep space galaxy',
                'abstract colorful geometry',
                'japanese cherry blossoms',
                'ancient ruins jungle',
                'surreal dreamscape',
                'neon lights night',
                'underwater coral reef',
                'winter wonderland',
                'steampunk machinery'
            ],
            defaultEffects: {
                intensity: 5,
                colorVariance: 50,
                activeEffect: 'brush'
            },
            cache: {
                enabled: true,
                maxAge: 24 * 60 * 60 * 1000 // 24 horas
            }
        };
        
        // Elementos DOM
        const elements = {
            canvas: document.getElementById('artCanvas'),
            ctx: document.getElementById('artCanvas').getContext('2d'),
            searchInput: document.getElementById('searchInput'),
            generateBtn: document.getElementById('generateBtn'),
            saveBtn: document.getElementById('saveBtn'),
            randomBtn: document.getElementById('randomBtn'),
            shareBtn: document.getElementById('shareBtn'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            toggleSettings: document.getElementById('toggleSettings'),
            settingsPanel: document.getElementById('settingsPanel'),
            effectIntensity: document.getElementById('effectIntensity'),
            colorVariance: document.getElementById('colorVariance'),
            effectButtons: document.querySelectorAll('.effect-btn')
        };
        
        // Estado da aplicação
        const state = {
            currentImage: null,
            currentTheme: '',
            isLoading: false,
            effects: {...CONFIG.defaultEffects},
            history: [],
            historyIndex: -1
        };
        
        // Inicialização
        document.addEventListener('DOMContentLoaded', () => {
            setupCanvas();
            setupEventListeners();
            checkURLParams();
            
            // Verificar se há suporte para Service Worker e Cache API
            if ('serviceWorker' in navigator && 'caches' in window) {
                registerServiceWorker();
            }
            
            // Carregar preferências do localStorage
            loadPreferences();
            
            // Gerar um tema aleatório inicial
            if (!state.currentTheme) {
                generateRandomTheme();
            }
        });
        
        function setupCanvas() {
            const size = Math.min(window.innerWidth - 40, 600);
            elements.canvas.width = size;
            elements.canvas.height = size;
            drawPlaceholder();
        }
        
        function drawPlaceholder() {
            const {ctx, canvas} = elements;
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#f0f0f0');
            gradient.addColorStop(1, '#e0e0e0');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#999';
            ctx.font = '16px Poppins';
            ctx.textAlign = 'center';
            
            const lines = [
                'Digite um tema acima',
                'e clique em "Gerar Arte"',
                'ou use um tema aleatório'
            ];
            
            lines.forEach((line, i) => {
                ctx.fillText(line, canvas.width/2, canvas.height/2 - 20 + (i * 25));
            });
            
            // Adicionar um ícone decorativo
            ctx.font = '48px "Font Awesome 6 Free"';
            ctx.fillText('\uf53f', canvas.width/2, canvas.height/2 - 70);
        }
        
        function setupEventListeners() {
            // Eventos de geração
            elements.generateBtn.addEventListener('click', handleGenerate);
            elements.searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleGenerate();
            });
            
            // Debounce para busca enquanto digita
            let searchTimeout;
            elements.searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    if (elements.searchInput.value.trim().length > 2) {
                        handleGenerate();
                    }
                }, 800);
            });
            
            // Eventos de controle
            elements.saveBtn.addEventListener('click', saveImage);
            elements.randomBtn.addEventListener('click', generateRandomTheme);
            elements.shareBtn.addEventListener('click', shareArtwork);
            
            // Eventos de efeitos
            elements.toggleSettings.addEventListener('click', toggleSettingsPanel);
            elements.effectIntensity.addEventListener('input', updateEffectSettings);
            elements.colorVariance.addEventListener('input', updateEffectSettings);
            
            elements.effectButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    elements.effectButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.effects.activeEffect = btn.dataset.effect;
                    if (state.currentImage) {
                        applyArtisticEffects(state.currentImage);
                    }
                    savePreferences();
                });
            });
            
            // Eventos de janela
            window.addEventListener('resize', () => {
                setupCanvas();
                if (state.currentImage) {
                    applyArtisticEffects(state.currentImage);
                }
            });
        }
        
        function toggleSettingsPanel() {
            elements.settingsPanel.style.display = 
                elements.settingsPanel.style.display === 'block' ? 'none' : 'block';
            savePreferences();
        }
        
        function updateEffectSettings() {
            state.effects.intensity = parseInt(elements.effectIntensity.value);
            state.effects.colorVariance = parseInt(elements.colorVariance.value);
            
            if (state.currentImage) {
                applyArtisticEffects(state.currentImage);
            }
            
            savePreferences();
        }
        
        async function handleGenerate() {
            const query = elements.searchInput.value.trim();
            if (!query || state.isLoading) return;
            
            try {
                state.currentTheme = query;
                updateURLParams();
                showLoading(true);
                
                // Verificar cache primeiro
                const cachedImage = CONFIG.cache.enabled ? await checkImageCache(query) : null;
                
                if (cachedImage) {
                    state.currentImage = cachedImage;
                    await applyArtisticEffects(cachedImage);
                } else {
                    const imageUrl = await fetchUnsplashImage(query);
                    state.currentImage = imageUrl;
                    await applyArtisticEffects(imageUrl);
                    
                    // Armazenar no cache
                    if (CONFIG.cache.enabled) {
                        cacheImage(query, imageUrl);
                    }
                }
                
                // Adicionar ao histórico
                addToHistory(query);
            } catch (error) {
                console.error("Erro ao gerar arte:", error);
                showError("Não foi possível criar a arte. Tente outro termo ou verifique sua conexão.");
            } finally {
                showLoading(false);
            }
        }
        
        async function checkImageCache(query) {
            if (!CONFIG.cache.enabled) return null;
            
            try {
                const cache = await caches.open('art-generator-cache');
                const cacheKey = `image-${encodeURIComponent(query)}`;
                const response = await cache.match(cacheKey);
                
                if (response) {
                    const blob = await response.blob();
                    return URL.createObjectURL(blob);
                }
                return null;
            } catch (error) {
                console.warn("Erro ao acessar cache:", error);
                return null;
            }
        }
        
        async function cacheImage(query, imageUrl) {
            try {
                const cache = await caches.open('art-generator-cache');
                const cacheKey = `image-${encodeURIComponent(query)}`;
                const response = await fetch(imageUrl);
                
                if (response.ok) {
                    await cache.put(cacheKey, response.clone());
                }
            } catch (error) {
                console.warn("Erro ao armazenar no cache:", error);
            }
        }
        
        async function fetchUnsplashImage(query) {
            try {
                const response = await fetch(
                    `https://api.unsplash.com/search/photos?query=${encodeURIComponent(query)}&per_page=5&client_id=${CONFIG.unsplashAccessKey}`
                );
                
                if (!response.ok) {
                    throw new Error(`Erro na API: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.results || data.results.length === 0) {
                    throw new Error("Nenhuma imagem encontrada para este tema");
                }
                
                // Selecionar uma imagem aleatória entre os resultados
                const randomIndex = Math.floor(Math.random() * Math.min(5, data.results.length));
                return data.results[randomIndex].urls.regular;
            } catch (error) {
                console.error("Erro ao buscar imagem:", error);
                throw error;
            }
        }
        
        async function applyArtisticEffects(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                
                img.onload = function() {
                    // Redimensionar mantendo proporção
                    const ratio = Math.min(
                        elements.canvas.width / img.width,
                        elements.canvas.height / img.height
                    );
                    const newWidth = img.width * ratio;
                    const newHeight = img.height * ratio;
                    
                    // Limpar e desenhar a imagem base
                    elements.ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                    elements.ctx.save();
                    elements.ctx.drawImage(
                        img,
                        (elements.canvas.width - newWidth) / 2,
                        (elements.canvas.height - newHeight) / 2,
                        newWidth,
                        newHeight
                    );
                    
                    // Aplicar efeito selecionado
                    switch (state.effects.activeEffect) {
                        case 'brush':
                            applyBrushStrokeEffect();
                            break;
                        case 'pixels':
                            applyPixelEffect();
                            break;
                        case 'glitch':
                            applyGlitchEffect();
                            break;
                        case 'watercolor':
                            applyWatercolorEffect();
                            break;
                        default:
                            applyBrushStrokeEffect();
                    }
                    
                    elements.ctx.restore();
                    resolve();
                };
                
                img.src = imageUrl;
            });
        }
        
        function applyBrushStrokeEffect() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const colorVar = state.effects.colorVariance;
            
            // Configurar parâmetros baseados na intensidade
            const strokeCount = 100 + (intensity * 30);
            const maxSize = 20 + (intensity * 5);
            const opacity = 0.05 + (intensity * 0.01);
            
            // Criar uma máscara de pinceladas
            ctx.globalCompositeOperation = 'overlay';
            
            for (let i = 0; i < strokeCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * maxSize + 10;
                
                // Obter cor do pixel na posição
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                let hue = Math.random() * colorVar - (colorVar / 2);
                
                if (pixel[3] > 0) {
                    // Converter RGB para HSL e variar a matiz
                    const rgb = [pixel[0]/255, pixel[1]/255, pixel[2]/255];
                    const max = Math.max(...rgb);
                    const min = Math.min(...rgb);
                    let h = 0;
                    
                    if (max !== min) {
                        const d = max - min;
                        switch(max) {
                            case rgb[0]: h = (rgb[1] - rgb[2]) / d + (rgb[1] < rgb[2] ? 6 : 0); break;
                            case rgb[1]: h = (rgb[2] - rgb[0]) / d + 2; break;
                            case rgb[2]: h = (rgb[0] - rgb[1]) / d + 4; break;
                        }
                        h /= 6;
                    }
                    
                    hue = (h * 360 + hue) % 360;
                }
                
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${opacity})`;
                
                // Criar formas de pincel variadas
                ctx.beginPath();
                
                if (Math.random() > 0.7) {
                    // Pincelada retangular
                    const rotation = Math.random() * Math.PI * 2;
                    const width = size;
                    const height = size * (0.3 + Math.random() * 0.7);
                    
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    ctx.rect(-width/2, -height/2, width, height);
                    ctx.translate(-x, -y);
                } else if (Math.random() > 0.5) {
                    // Pincelada circular
                    ctx.arc(x, y, size/2, 0, Math.PI * 2);
                } else {
                    // Pincelada triangular
                    ctx.moveTo(x, y - size/2);
                    ctx.lineTo(x + size/2, y + size/2);
                    ctx.lineTo(x - size/2, y + size/2);
                }
                
                ctx.fill();
            }
            
            ctx.globalCompositeOperation = 'source-over';
            
            // Adicionar textura final
            addPaperTexture();
        }
        
        function applyPixelEffect() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const pixelSize = 10 - (intensity * 0.8);
            
            if (pixelSize <= 1) return;
            
            // Obter dados da imagem
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Aplicar efeito pixelado
            for (let y = 0; y < canvas.height; y += pixelSize) {
                for (let x = 0; x < canvas.width; x += pixelSize) {
                    // Obter a cor média na área do pixel
                    const pixelIndex = (y * canvas.width + x) * 4;
                    const r = data[pixelIndex];
                    const g = data[pixelIndex + 1];
                    const b = data[pixelIndex + 2];
                    
                    // Desenhar quadrado com a cor média
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, pixelSize, pixelSize);
                }
            }
            
            // Adicionar bordas entre pixels para efeito mais pronunciado
            if (intensity > 5) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 0.5;
                
                for (let y = 0; y <= canvas.height; y += pixelSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                for (let x = 0; x <= canvas.width; x += pixelSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
            }
        }
        
        function applyGlitchEffect() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const colorVar = state.effects.colorVariance;
            
            // Obter dados da imagem
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Aplicar variação de cor
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < colorVar/500) {
                    // Deslocar canais de cor
                    const shift = Math.floor(Math.random() * 20 * (intensity/5)) - (10 * (intensity/5));
                    data[i] = Math.min(255, Math.max(0, data[i] + shift));     // R
                    data[i+1] = Math.min(255, Math.max(0, data[i+1] - shift)); // G
                    data[i+2] = Math.min(255, Math.max(0, data[i+2] + shift)); // B
                }
            }
            
            // Aplicar linhas de glitch
            const glitchLines = intensity * 5;
            for (let i = 0; i < glitchLines; i++) {
                const y = Math.floor(Math.random() * canvas.height);
                const height = 1 + Math.floor(Math.random() * 5 * (intensity/5));
                const shift = (Math.random() > 0.5 ? 1 : -1) * Math.floor(Math.random() * 20 * (intensity/5));
                
                const sourceY = Math.max(0, Math.min(canvas.height - height, y + shift));
                const destY = Math.max(0, Math.min(canvas.height - height, y));
                
                const glitchData = ctx.getImageData(0, sourceY, canvas.width, height);
                ctx.putImageData(glitchData, 0, destY);
            }
            
            // Aplicar blocos deslocados
            if (intensity > 5) {
                const blocks = Math.floor(intensity / 2);
                for (let i = 0; i < blocks; i++) {
                    const width = 10 + Math.floor(Math.random() * 50);
                    const height = 5 + Math.floor(Math.random() * 20);
                    const x = Math.floor(Math.random() * (canvas.width - width));
                    const y = Math.floor(Math.random() * (canvas.height - height));
                    const shiftX = (Math.random() > 0.5 ? 1 : -1) * Math.floor(Math.random() * 30);
                    
                    const blockData = ctx.getImageData(x, y, width, height);
                    ctx.putImageData(blockData, x + shiftX, y);
                }
            }
            
            // Adicionar ruído digital
            addDigitalNoise();
        }
        
        function applyWatercolorEffect() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const colorVar = state.effects.colorVariance;
            
            // Criar um canvas temporário para o efeito
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Desenhar a imagem original no canvas temporário
            tempCtx.drawImage(canvas, 0, 0);
            
            // Aplicar desfoque para simular aquarela
            const blurAmount = intensity * 2;
            tempCtx.filter = `blur(${blurAmount}px)`;
            tempCtx.drawImage(tempCanvas, 0, 0);
            tempCtx.filter = 'none';
            
            // Desenhar de volta no canvas principal com transparência
            ctx.globalAlpha = 0.7;
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.globalAlpha = 1.0;
            
            // Adicionar pinceladas de aquarela
            const strokeCount = 50 + (intensity * 20);
            const maxSize = 30 + (intensity * 5);
            
            for (let i = 0; i < strokeCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * maxSize + 10;
                
                // Obter cor do pixel na posição com variação
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                const hueShift = (Math.random() * colorVar) - (colorVar / 2);
                
                let r = pixel[0], g = pixel[1], b = pixel[2];
                
                if (pixel[3] > 0) {
                    // Converter para HSL, variar e converter de volta
                    const hsl = rgbToHsl(r, g, b);
                    hsl[0] = (hsl[0] + hueShift/360) % 1;
                    hsl[1] = Math.min(1, hsl[1] * (1 + (Math.random() * 0.2)));
                    hsl[2] = hsl[2] * (0.9 + Math.random() * 0.2);
                    
                    const rgb = hslToRgb(...hsl);
                    r = rgb[0];
                    g = rgb[1];
                    b = rgb[2];
                }
                
                // Criar pincelada com bordas difusas
                const gradient = ctx.createRadialGradient(
                    x, y, 0,
                    x, y, size
                );
                
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
                gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.1)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Adicionar textura de papel
            addPaperTexture(0.3);
        }
        
        function addDigitalNoise() {
            const {ctx, canvas} = elements;
            const intensity = state.effects.intensity;
            const noiseDensity = intensity / 20;
            
            // Criar ruído digital
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < noiseDensity) {
                    const val = Math.floor(Math.random() * 256);
                    data[i] = val;     // R
                    data[i+1] = val;   // G
                    data[i+2] = val;   // B
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function addPaperTexture(opacity = 0.1) {
            const {ctx, canvas} = elements;
            
            // Criar textura de papel
            ctx.globalAlpha = opacity || 0.1;
            
            for (let i = 0; i < canvas.width * canvas.height * 0.02; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 1.5;
                
                ctx.fillStyle = `rgba(200, 200, 200, ${Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        // Funções auxiliares de conversão de cor
        function rgbToHsl(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            return [h, s, l];
        }
        
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        function generateRandomTheme() {
            const randomTheme = CONFIG.randomThemes[Math.floor(Math.random() * CONFIG.randomThemes.length)];
            elements.searchInput.value = randomTheme;
            handleGenerate();
        }
        
        function saveImage() {
            if (!state.currentImage) return;
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = state.currentTheme 
                ? `arte-${state.currentTheme.toLowerCase().replace(/\s+/g, '-')}-${timestamp}`
                : `arte-generativa-${timestamp}`;
            
            link.download = `${filename}.png`;
            link.href = elements.canvas.toDataURL('image/png');
            link.click();
        }
        
        function shareArtwork() {
            if (!navigator.share) {
                // Fallback para copiar link
                const url = window.location.href.split('?')[0] + `?theme=${encodeURIComponent(state.currentTheme)}`;
                navigator.clipboard.writeText(url).then(() => {
                    alert('Link copiado para a área de transferência!');
                });
                return;
            }
            
            navigator.share({
                title: `Arte Generativa: ${state.currentTheme}`,
                text: 'Confira esta obra de arte generativa que criei:',
                url: window.location.href
            }).catch(err => {
                console.log('Erro ao compartilhar:', err);
            });
        }
        
        function showLoading(show) {
            state.isLoading = show;
            elements.loadingIndicator.style.display = show ? 'flex' : 'none';
            elements.generateBtn.disabled = show;
            
            if (show) {
                elements.generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processando...';
            } else {
                elements.generateBtn.innerHTML = '<i class="fas fa-magic"></i> Gerar Arte';
            }
        }
        
        function showError(message) {
            const errorEl = document.createElement('div');
            errorEl.className = 'error-message';
            errorEl.innerHTML = `
                <i class="fas fa-exclamation-circle"></i> ${message}
            `;
            errorEl.style.position = 'fixed';
            errorEl.style.top = '20px';
            errorEl.style.left = '50%';
            errorEl.style.transform = 'translateX(-50%)';
            errorEl.style.backgroundColor = 'var(--warning)';
            errorEl.style.color = 'white';
            errorEl.style.padding = '10px 20px';
            errorEl.style.borderRadius = '5px';
            errorEl.style.boxShadow = '0 3px 10px rgba(0,0,0,0.2)';
            errorEl.style.zIndex = '1000';
            errorEl.style.animation = 'fadeIn 0.3s ease-out';
            
            document.body.appendChild(errorEl);
            
            setTimeout(() => {
                errorEl.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => {
                    document.body.removeChild(errorEl);
                }, 300);
            }, 3000);
        }
        
        function updateURLParams() {
            if (!state.currentTheme) return;
            
            const url = new URL(window.location);
            url.searchParams.set('theme', state.currentTheme);
            window.history.pushState({}, '', url);
        }
        
        function checkURLParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const theme = urlParams.get('theme');
            
            if (theme) {
                elements.searchInput.value = theme;
                handleGenerate();
            }
        }
        
        function addToHistory(query) {
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(query);
            state.historyIndex = state.history.length - 1;
        }
        
        function loadPreferences() {
            const prefs = JSON.parse(localStorage.getItem('artGeneratorPrefs')) || {};
            
            if (prefs.effects) {
                state.effects = {...state.effects, ...prefs.effects};
                elements.effectIntensity.value = state.effects.intensity;
                elements.colorVariance.value = state.effects.colorVariance;
                
                // Ativar botão do efeito salvo
                elements.effectButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.effect === state.effects.activeEffect);
                });
            }
            
            if (prefs.settingsPanelVisible) {
                elements.settingsPanel.style.display = 'block';
            }
        }
        
        function savePreferences() {
            const prefs = {
                effects: state.effects,
                settingsPanelVisible: elements.settingsPanel.style.display === 'block'
            };
            
            localStorage.setItem('artGeneratorPrefs', JSON.stringify(prefs));
        }
        
        async function registerServiceWorker() {
            try {
                await navigator.serviceWorker.register('/sw.js');
                console.log('Service Worker registrado com sucesso');
            } catch (error) {
                console.log('Falha ao registrar Service Worker:', error);
            }
        }
    </script>
</body>
</html>